<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Engineering Approach — Socialbridge</title>
    <meta
      name="description"
      content="Learn how Socialbridge is built: modular architecture, sandbox transaction emulation, a portable theme editor, and 337 automated tests that protect every release."
    />
    <link rel="stylesheet" href="./style.css" />
  </head>
  <body>
    <main class="container">
      <header class="hero">
        <div class="badge">Process</div>
        <h1>Engineering Approach</h1>
        <p class="subtitle">
          Socialbridge is delivered through repeatable guardrails: modular packages, pre-flight simulations, portable design tooling, and a growing automated test lab.
        </p>
      </header>

      <section class="card">
        <h2>Architecture guardrails</h2>
        <p>
          The wallet ships as a modular stack of packages (core, domain, network, crypto runtime) so presentation layers stay thin and replaceable. Strict capability
          injection and a dual-vault model keep secrets sealed—keys live inside the secret vault, while the app vault stores confidential metadata such as account lists
          and history.
        </p>
        <ul>
          <li>Clear separation of secret vault, app vault, blockchain drivers, and experience layer</li>
          <li>Definition-of-done checklists for every module before it reaches users</li>
          <li>Architecture Decision Records capture each guardrail for future audits</li>
        </ul>
      </section>

      <section class="card">
        <h2>Cryptography stack</h2>
        <p>
          The vault encrypts every secret with libsodium primitives: Argon2id derives device-bound keys, and XChaCha20-Poly1305 keeps the ciphertext authenticated even if
          storage is copied. Per-record salts and nonces come from libsodium’s randombytes_buf (backed by the OS CSPRNG), so the same secret never encrypts to the same bytes twice.
        </p>
        <ul>
          <li>Argon2id hardening with tuned memory and time costs resists brute-force attempts on stolen backups</li>
          <li>XChaCha20-Poly1305 provides authenticated encryption with 192-bit nonces, preventing tampering and replay</li>
          <li>libsodium’s audited implementations run in constant time and ship with built-in secure wipe utilities</li>
        </ul>
      </section>

      <section class="card">
        <h2>Pre-flight simulation & risk gates</h2>
        <p>
          Before a TON transaction is broadcast, the wallet replays it through a local sandbox virtual machine. Users see final balances, money paths, and excess refunds
          with full fidelity, without sending real funds during the preview step.
        </p>
        <ul>
          <li>Full-chain sandbox emulator reproduces the contract execution without broadcasting</li>
          <li>Money-path inspector shows every hop, return, and jetton mint</li>
          <li>Risk engine issues bounce verdicts and compensation hints in plain language</li>
        </ul>
      </section>

      <section class="card">
        <h2>Theme & interface studio</h2>
        <p>
          A standalone theme editor manipulates runtime tokens, grids, and GPU shaders so partners can reskin the wallet or embed the editor inside their own apps. Layout
          constraints mirror design tools, enabling rapid brand-ready launches.
        </p>
        <ul>
          <li>Live editing of typography, icon sets, surfaces, and motion textures</li>
          <li>Portable editor package drops into any project with the same token schema</li>
          <li>Runtime CSS variable graph keeps design changes atomic and reversible</li>
        </ul>
      </section>

      <section class="card">
        <h2>Quality discipline</h2>
        <p>
          The project currently runs 337 automated tests across vault logic, DeFi flows, and UI contracts. Every feature ships with a prompt log, checklist, and rollback
          plan so regressions are easy to detect and unwind.
        </p>
        <ul>
          <li>Unit, integration, and scenario suites cover swaps, staking, and risk gates</li>
          <li>Prompt playbooks and modular rollout plans document each major refactor</li>
          <li>Release notes track what changed, why it changed, and how to revert safely</li>
        </ul>
      </section>

      <section class="card">
        <a class="btn" href="./index.html">Back to main page</a>
      </section>
    </main>
  </body>
</html>

